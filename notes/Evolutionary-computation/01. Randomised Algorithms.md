# Evolutionary Computation - Randomised Algorithms

<img src="https://www.tutorialspoint.com/data_structures_algorithms/images/randomized_algorithms.jpg" alt="Randomised" width="800">

---

## 1. Motivating Problems

### Problem 1: Matching One Bolt to \( n \) Nuts
- **Real-world analogy**: Given a bolt and a collection of \( n \) nuts of different sizes, find the matching nut.
- **Mathematical formulation**: Given an array of \( n \) elements, find the first element whose value equals \( x \).
- **Questions to consider**:
  - How can we solve this using an algorithm?
  - How can we do it efficiently?

### Problem 2: Nuts and Bolts Problem
- **Scenario**: A disorganized carpenter has a collection of \( n \) nuts and \( n \) bolts, each with a unique match.
- **Constraints**:
  - Nuts can only be compared to bolts (not other nuts).
  - Bolts can only be compared to nuts (not other bolts).
- **Challenge**:
  - How to efficiently pair them?
  - What algorithms can be used?

### Problem 3: Dan Brown’s Mars Problem
- **Scenario**:
  - Dan Brown is on Mars with a digital manuscript.
  - He wants to compare it with the final version stored on Earth.
  - Communication is expensive.
- **Key challenge**: Efficiently comparing two long strings with minimal communication.

---

## 2. Randomised Algorithms

### Definition
> "For many problems, a randomised algorithm is the simplest, the fastest, or both." – Prabhakar Raghavan

### Categories of Algorithms
1. **Divide and Conquer** (e.g., Quicksort)
2. **Dynamic Programming**
3. **Mathematical Programming** (e.g., Linear Programming)
4. **Search and Enumeration**
5. **Brute Force**
   - Exhaustive search
   - Improved brute force (e.g., branch and bound)
6. **Heuristic Algorithms**
   - Local search (e.g., greedy search)
   - Randomised algorithms

### Heuristic Algorithms
- **Definition**: Approximate solutions in a reasonable time frame.
- **Trade-offs**: Speed vs. accuracy/completeness.
- **Use cases**:
  - Problems difficult for brute force methods.
  - Deterministic (e.g., local search) vs. randomised methods.

### Randomised Algorithms
- **Definition**: An algorithm that makes random choices during execution.
- **Characteristics**:
  - Uses a source of randomness.
  - Output or runtime can vary for the same input.
  - Goal: Ensure likely good performance on every input.

### Randomised vs. Deterministic Algorithms
| Type | Input | Output |
|------|-------|--------|
| **Deterministic** | Fixed | Fixed |
| **Randomised** | Fixed + Random Number | Variable |

---

## 3. Solving the Problems

### Categories of Randomised Algorithms
1. **Using random numbers to find a solution**
2. **Using random numbers to improve a solution**

### Problem 1: Finding an Element in an Array
#### **Solution 1: Las Vegas Algorithm**
```python
repeat:
    Randomly select an element a from n elements
until a == x
```
- **Key properties**:
  - Always correct but runtime varies.
  - Runs until the correct answer is found.

#### **Solution 2: Monte Carlo Algorithm**
```python
i = 0
repeat:
    Randomly select an element a from n elements
    i += 1
until (a == x) or (i == k)
```
- **Key properties**:
  - Runs for a fixed number of steps.
  - May produce incorrect results with some probability.

#### **Comparison**
| Algorithm | Guarantee | Running Time |
|-----------|----------|--------------|
| **Las Vegas** | Always correct | Variable |
| **Monte Carlo** | Fixed steps | Possible errors |

### Problem 2: Nuts and Bolts Problem
- **Brute-force solution**: Compare each nut to all bolts (\( O(n^2) \)).
- **Optimized approach**: Use a **randomised quicksort** variant:
  1. Select a pivot (random nut or bolt).
  2. Partition nuts based on the pivot bolt.
  3. Partition bolts based on the pivot nut.
  4. Recursively sort both groups.
- **Complexity**: \( O(n \log n) \) on average.

### Problem 3: Comparing Two Large Strings
- **Challenge**: Limited communication bandwidth.
- **Solution**: Use **hashing** (e.g., Rabin-Karp Algorithm):
  1. Compute a hash for each string.
  2. Transmit only the hash values.
  3. Compare hashes to detect mismatches.
- **Efficiency**: Reduces communication overhead drastically.

---

## 4. Conclusion
- **Randomised algorithms** offer simplicity and efficiency.
- **Trade-offs**:
  - Monte Carlo: Bounded runtime, possible errors.
  - Las Vegas: Always correct, unbounded runtime.
- **Applications**:
  - Sorting (Randomised Quicksort)
  - Searching (Las Vegas, Monte Carlo)
  - Optimization (Genetic Algorithms)
